// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Js_types from "rescript/lib/es6/js_types.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as HashUtils from "./HashUtils.bs.js";

var symbol = (Symbol.for('ELEM_NODE'));

function createPrimitive(kind, props, children) {
  return {
          symbol: symbol,
          kind: {
            NAME: "Primitive",
            VAL: kind
          },
          props: props,
          children: Belt_List.fromArray(children)
        };
}

function createComposite(kind, props, children) {
  return {
          symbol: symbol,
          kind: {
            NAME: "Composite",
            VAL: kind
          },
          props: props,
          children: Belt_List.fromArray(children)
        };
}

function isNode(a) {
  var match = Js_types.classify(a);
  if (typeof match === "number") {
    return false;
  }
  if (match.TAG !== /* JSObject */3) {
    return false;
  }
  var s = Js_types.classify(a.symbol);
  if (typeof s === "number" || s.TAG !== /* JSSymbol */4) {
    return false;
  } else {
    return s._0 === symbol;
  }
}

function getHashUnchecked(n) {
  var x = n.hash;
  if (x !== undefined) {
    return x;
  } else {
    return Js_exn.raiseError("Missing hash property");
  }
}

function shallowCopy(node) {
  var match = node.kind;
  if (match.NAME === "Composite") {
    return Js_exn.raiseError("Attempting to shallow copy a composite node");
  } else {
    return {
            symbol: symbol,
            hash: getHashUnchecked(node),
            kind: match.VAL,
            props: Object.assign({}, node.props),
            generation: {
              contents: 0
            }
          };
  }
}

var NodeRepr = {
  symbol: symbol,
  createPrimitive: createPrimitive,
  createComposite: createComposite,
  isNode: isNode,
  getHashUnchecked: getHashUnchecked,
  shallowCopy: shallowCopy
};

function valuesArray(m) {
  return Array.from(m.values());
}

var $$Map = {
  valuesArray: valuesArray
};

var $$Set = {};

var RenderDelegate = {};

function getOrCreateMemo(memoMap, fn) {
  if (memoMap.has(fn)) {
    return memoMap.get(fn);
  }
  var memTable = new Map();
  var memoized = function (lookupKey, context, props, children) {
    if (memTable.has(lookupKey)) {
      return memTable.get(lookupKey);
    }
    var resolved = Curry._1(fn, {
          context: context,
          props: props,
          children: Belt_List.toArray(children)
        });
    memTable.set(lookupKey, resolved);
    return resolved;
  };
  memoMap.set(fn, memoized);
  return memoized;
}

function mount(delegate, node, kind, hash, childHashes) {
  var nodeMap = delegate.getNodeMap();
  if (nodeMap.has(hash)) {
    var existing = nodeMap.get(hash);
    HashUtils.updateNodeProps(delegate, HashUtils.hashToHexId(hash), existing.props, node.props);
    nodeMap.set(hash, shallowCopy(node));
    return ;
  }
  delegate.createNode(HashUtils.hashToHexId(hash), kind);
  HashUtils.updateNodeProps(delegate, HashUtils.hashToHexId(hash), {}, node.props);
  childHashes.forEach(function (ch) {
        delegate.appendChild(HashUtils.hashToHexId(hash), HashUtils.hashToHexId(ch));
      });
  nodeMap.set(hash, shallowCopy(node));
}

function visit(delegate, visitSet, compositeMap, _ns) {
  while(true) {
    var ns = _ns;
    var visited = function (x) {
      return visitSet.has(x);
    };
    if (!ns) {
      return ;
    }
    var rest = ns.tl;
    var n = ns.hd;
    if (visitSet.has(n)) {
      _ns = rest;
      continue ;
    }
    var childrenVisited = Belt_List.every(n.children, visited);
    if (childrenVisited) {
      var childHashes = Belt_List.toArray(Belt_List.map(n.children, (function (child) {
                  var match = child.kind;
                  if (match.NAME === "Composite") {
                    return getHashUnchecked(compositeMap.get(child));
                  } else {
                    return getHashUnchecked(child);
                  }
                })));
      var match = n.kind;
      if (match.NAME === "Composite") {
        var mfn = getOrCreateMemo(delegate.getMemoMap(), match.VAL);
        var context = delegate.getRenderContext();
        var lookupKey = HashUtils.hashMemoInputs(n.props, childHashes);
        var resolved = Curry._4(mfn, lookupKey, context, n.props, n.children);
        compositeMap.set(n, resolved);
        visitSet.add(n);
        _ns = Belt_List.add(rest, resolved);
        continue ;
      }
      var k = match.VAL;
      var hash = HashUtils.hashNode(k, n.props, childHashes);
      n.hash = hash;
      mount(delegate, n, k, hash, childHashes);
      visitSet.add(n);
      _ns = rest;
      continue ;
    }
    _ns = Belt_List.concat(n.children, ns);
    continue ;
  };
}

function renderWithDelegate(delegate, graphs) {
  var visitSet = new Set();
  var compositeMap = new Map();
  var roots = Belt_List.mapWithIndex(Belt_List.fromArray(graphs), (function (i, g) {
          return createPrimitive("root", {
                      channel: i
                    }, [g]);
        }));
  visit(delegate, visitSet, compositeMap, roots);
  delegate.activateRoots(Belt_List.toArray(Belt_List.map(roots, (function (r) {
                  return HashUtils.hashToHexId(getHashUnchecked(r));
                }))));
  delegate.commitUpdates();
}

function stepGarbageCollector(delegate) {
  var nodeMap = delegate.getNodeMap();
  var term = delegate.getTerminalGeneration();
  var deleted = Array.from(nodeMap.values()).reduce((function (acc, n) {
          n.generation.contents = n.generation.contents + 1 | 0;
          if (n.generation.contents >= term) {
            delegate.deleteNode(HashUtils.hashToHexId(n.hash));
            return Belt_List.add(acc, n);
          } else {
            return acc;
          }
        }), /* [] */0);
  if (Belt_List.length(deleted) > 0) {
    delegate.commitUpdates();
    return Belt_List.forEach(deleted, (function (n) {
                  nodeMap.delete(n.hash);
                }));
  }
  
}

export {
  NodeRepr ,
  $$Map ,
  $$Set ,
  RenderDelegate ,
  getOrCreateMemo ,
  mount ,
  visit ,
  renderWithDelegate ,
  stepGarbageCollector ,
}
/* symbol Not a pure module */
