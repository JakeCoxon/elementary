// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Js_types from "rescript/lib/es6/js_types.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as HashUtils from "./HashUtils.bs.js";
import * as Js_option from "rescript/lib/es6/js_option.js";

var symbol = (Symbol.for('ELEM_NODE'));

function createPrimitive(kind, props, children) {
  return {
          symbol: symbol,
          kind: {
            NAME: "Primitive",
            VAL: kind
          },
          props: props,
          children: Belt_List.fromArray(children)
        };
}

function createComposite(fn, props, children) {
  return {
          symbol: symbol,
          kind: {
            NAME: "Composite",
            VAL: [
              {
                contents: undefined
              },
              fn
            ]
          },
          props: props,
          children: Belt_List.fromArray(children)
        };
}

function isNode(a) {
  var match = Js_types.classify(a);
  if (typeof match === "number") {
    return false;
  }
  if (match.TAG !== /* JSObject */3) {
    return false;
  }
  var s = Js_types.classify(a.symbol);
  if (typeof s === "number" || s.TAG !== /* JSSymbol */4) {
    return false;
  } else {
    return s._0 === symbol;
  }
}

function getHashUnchecked(n) {
  var x = n.hash;
  if (x !== undefined) {
    return x;
  } else {
    return Js_exn.raiseError("Missing hash property");
  }
}

function shallowCopy(node) {
  var match = node.kind;
  if (match.NAME === "Composite") {
    return Js_exn.raiseError("Attempting to shallow copy a composite node");
  } else {
    return {
            symbol: symbol,
            hash: getHashUnchecked(node),
            kind: match.VAL,
            props: Object.assign({}, node.props),
            generation: {
              contents: 0
            }
          };
  }
}

var NodeRepr = {
  symbol: symbol,
  createPrimitive: createPrimitive,
  createComposite: createComposite,
  isNode: isNode,
  getHashUnchecked: getHashUnchecked,
  shallowCopy: shallowCopy
};

function valuesArray(m) {
  return Array.from(m.values());
}

var $$Map = {
  valuesArray: valuesArray
};

var $$Set = {};

var RenderDelegate = {};

function getOrCreateMemo(memoMap, fn) {
  if (memoMap.has(fn)) {
    return memoMap.get(fn);
  }
  var memTable = new Map();
  var memoized = function (lookupKey, context, props, children) {
    if (memTable.has(lookupKey)) {
      return memTable.get(lookupKey);
    }
    var resolved = Curry._1(fn, {
          context: context,
          props: props,
          children: Belt_List.toArray(children)
        });
    memTable.set(lookupKey, resolved);
    return resolved;
  };
  memoMap.set(fn, memoized);
  return memoized;
}

function mount(delegate, node, kind, hash, childHashes) {
  var nodeMap = delegate.getNodeMap();
  if (nodeMap.has(hash)) {
    var existing = nodeMap.get(hash);
    HashUtils.updateNodeProps(delegate, hash, existing.props, node.props);
    nodeMap.set(hash, shallowCopy(node));
    return ;
  }
  delegate.createNode(hash, kind);
  HashUtils.updateNodeProps(delegate, hash, {}, node.props);
  Belt_List.forEach(childHashes, (function (ch) {
          delegate.appendChild(hash, ch);
        }));
  nodeMap.set(hash, shallowCopy(node));
}

function visit(delegate, visitSet, compositeMap, _ns) {
  while(true) {
    var ns = _ns;
    var visited = function (x) {
      return visitSet.has(x);
    };
    if (!ns) {
      return ;
    }
    var rest = ns.tl;
    var n = ns.hd;
    if (visitSet.has(n)) {
      _ns = rest;
      continue ;
    }
    var childrenVisited = Belt_List.every(n.children, visited);
    if (childrenVisited) {
      var childHashes = Belt_List.map(n.children, (function (child) {
              return Js_option.getExn(child.hash);
            }));
      var match = n.kind;
      if (match.NAME === "Composite") {
        var match$1 = match.VAL;
        var res = match$1[0];
        var context = delegate.getRenderContext();
        var n$1 = res.contents;
        var resolved = n$1 !== undefined ? n$1 : Curry._1(match$1[1], {
                context: context,
                props: n.props,
                children: Belt_List.toArray(n.children)
              });
        res.contents = resolved;
        if (visitSet.has(resolved)) {
          n.hash = Js_option.getExn(resolved.hash);
          visitSet.add(n);
          _ns = rest;
          continue ;
        }
        _ns = Belt_List.add(Belt_List.add(rest, n), resolved);
        continue ;
      }
      var k = match.VAL;
      var hash = HashUtils.hashNode(k, n.props, childHashes);
      n.hash = hash;
      mount(delegate, n, k, hash, childHashes);
      visitSet.add(n);
      _ns = rest;
      continue ;
    }
    _ns = Belt_List.concat(n.children, ns);
    continue ;
  };
}

function renderWithDelegate(delegate, graphs) {
  var visitSet = new Set();
  var compositeMap = new Map();
  var roots = Belt_List.mapWithIndex(Belt_List.fromArray(graphs), (function (i, g) {
          return createPrimitive("root", {
                      channel: i
                    }, [g]);
        }));
  visit(delegate, visitSet, compositeMap, roots);
  delegate.activateRoots(Belt_List.toArray(Belt_List.map(roots, getHashUnchecked)));
  delegate.commitUpdates();
}

function stepGarbageCollector(delegate) {
  var nodeMap = delegate.getNodeMap();
  var term = delegate.getTerminalGeneration();
  var deleted = Array.from(nodeMap.values()).reduce((function (acc, n) {
          n.generation.contents = n.generation.contents + 1 | 0;
          if (n.generation.contents >= term) {
            delegate.deleteNode(n.hash);
            return Belt_List.add(acc, n);
          } else {
            return acc;
          }
        }), /* [] */0);
  if (Belt_List.length(deleted) > 0) {
    delegate.commitUpdates();
    return Belt_List.forEach(deleted, (function (n) {
                  nodeMap.delete(n.hash);
                }));
  }
  
}

export {
  NodeRepr ,
  $$Map ,
  $$Set ,
  RenderDelegate ,
  getOrCreateMemo ,
  mount ,
  visit ,
  renderWithDelegate ,
  stepGarbageCollector ,
}
/* symbol Not a pure module */
